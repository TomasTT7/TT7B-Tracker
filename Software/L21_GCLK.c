/*
	Generic Clock Controller (GCLK)
		Generic Clock Generators are programmable prescalers that can use any of the system clock sources as a time base.
		Generic Clocks are clock signals generated by Generic Clock Generators and output by the Peripheral Channels,
		and serve as clocks for the peripherals of the system.
	
	Main Clock Controller (MCLK)
		It generates and controls synchronous clocks on the system. This includes the CPU, bus clocks (APB, AHB)
		as well as the synchronous (to the CPU) user interfaces of the peripherals.
		The AHB and APB clocks for a peripherals are all enabled by default.
		In STANDBY sleep mode, the MCLK is frozen if no synchronous clock is required.
		The source of MCLK is GCLK_MAIN - GCLK[0].
	
	All peripherals are composed of one digital bus interface connected to the APB or AHB bus and running from
	a corresponding clock in the Main Clock domain, and one peripheral core running from the peripheral Generic Clock (GCLK).
	All registers in the bus interface are accessible without synchronization. All registers in the peripheral core
	are synchronized when written. Some registers in the peripheral core are synchronized when read.
	
	On any Reset the synchronous clocks start to their initial state:
		OSC16M is enabled and configured to run at 4MHz
		Generic Generator 0 uses OSC16M as source and generates GCLK_MAIN
		CPU and BUS clocks are undivided
	On a Power-on Reset, the 32KHz clock sources are reset and the GCLK module starts to its initial state:
		All Generic Clock Generators are disabled except
			Generator 0 is using OSC16M at 4MHz as source and generates GCLK_MAIN
		All Peripheral Channels in GCLK are disabled.
	On a User Reset the GCLK module starts to its initial state, except for:
		Generic Clocks that are write-locked, i.e., the according WRTLOCK is set to 1 prior to Reset
*/


#include "sam.h"
#include "L21_GCLK.h"


/*
	GCLK	0-8
	
	Before a Generator is enabled, the corresponding clock source should be enabled.
	
	The Generator must be enabled and the division factor must be set by performing
	a single 32-bit write to the Generator Control register.
	
	DIV
		Generic Clock Generator		Division Factor Bits
		Generator 0					8 division factor bits		DIV[7:0]
		Generator 1					16 division factor bits		DIV[15:0]
		Generator 2-8				8 division factor bits		DIV[7:0]	
	RUNSTDBY
		0	The Generator is stopped in Standby.
		1	The Generator is kept running and output to its dedicated GCLK_IO pin during Standby mode.
	
	DIVSEL
		0	The Generator clock frequency equals the clock source frequency divided by GENCTRLn.DIV.
		1	The Generator clock frequency equals the clock source frequency divided by 2^(GENCTRLn.DIV+1).
	
	SRC
		0x00	XOSC		XOSC oscillator output
		0x01	GCLK_IN		Generator input pad (GCLK_IO)
		0x02	GCLK_GEN1	Generic clock generator 1 output
		0x03	OSCULP32K	OSCULP32K oscillator output
		0x04	OSC32K		OSC32K oscillator output
		0x05	XOSC32K		XOSC32K oscillator output
		0x06	OSC16M		OSC16M oscillator output
		0x07	DFLL48M		DFLL48M output
		0x08	DPLL96M		DPLL96M output
*/
void GCLK_x_enable(uint8_t gclk, uint8_t src, uint8_t div, uint8_t divsel, uint8_t runstdby)
{
	if(gclk > 8 || src > 8) return;
	
	GCLK->GENCTRL[gclk].reg = (div << 16) | (runstdby << 13) | (divsel << 12) | (0x01 << 9) | (0x01 << 8) | src;
	while(GCLK->SYNCBUSY.reg & (0x01 << (gclk + 2)));
}


/*
	GCLK	0-8
*/
void GCLK_x_disable(uint8_t gclk)
{
	if(gclk < 9) GCLK->GENCTRL[gclk].bit.GENEN = 0;
}


/*
	The division ratio of the main clock prescaler.
	Frequencies must be selected so that F_CPU ? F_LP (i.e. LPDIV ? CPUDIV).
	
	CPUDIV
		0x01	DIV1	Divide by 1
		0x02	DIV2	Divide by 2
		0x04	DIV4	Divide by 4
		0x08	DIV8	Divide by 8
		0x10	DIV16	Divide by 16
		0x20	DIV32	Divide by 32
		0x40	DIV64	Divide by 64
		0x80	DIV128	Divide by 128
		
	Default: DIV1
*/
void MCLK_set_prescaler_CPU(uint8_t cpudiv)
{
	MCLK->CPUDIV.reg = cpudiv;
	while(!(MCLK->INTFLAG.bit.CKRDY));
}


/*
	The division ratio of the main clock prescaler (2^n).
	Frequencies must be selected so that F_CPU ? F_LP ? F_BUP (i.e. BUPDIV ? LPDIV ? CPUDIV).
	
	LPDIV
		0x01	DIV1	Divide by 1
		0x02	DIV2	Divide by 2
		0x04	DIV4	Divide by 4
		0x08	DIV8	Divide by 8
		0x10	DIV16	Divide by 16
		0x20	DIV32	Divide by 32
		0x40	DIV64	Divide by 64
		0x80	DIV128	Divide by 128
		
	Default: DIV1
*/
void MCLK_set_prescaler_LP(uint8_t lpdiv)
{
	MCLK->LPDIV.reg = lpdiv;
	while(!(MCLK->INTFLAG.bit.CKRDY));
}


/*

*/
void MCLK_set_prescaler_BUP(uint8_t bupdiv)
{
	MCLK->BUPDIV.reg = bupdiv;
	while(!(MCLK->INTFLAG.bit.CKRDY));
}